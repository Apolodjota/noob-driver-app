<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulador Conceptual: Cambio de Marchas</title>
<style>
  html, body { height: 100%; margin: 0; background:#0f1418; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; }
  #wrap { height: 100%; display: grid; place-items: center; }
  canvas { border-radius: 14px; box-shadow: 0 10px 40px rgba(0,0,0,.35); background:#0a0e12; }
  .hud { position: fixed; left: 16px; bottom: 50px; color:#d6e6ff; font-size: 20px; opacity:.6 }
  .ai-tools { position: fixed; right: 16px; top: 16px; display: flex; gap: 8px; align-items: center; }
  .ai-tools button { padding: 8px 12px; border-radius: 8px; border: 1px solid #2a3a46; background:#14202a; color:#d8ecff; cursor: pointer; }
  .agent-panel { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(5,8,12,0.72); }
  .agent-card { width: 720px; max-width: calc(100% - 40px); background: #10161d; color:#e8f2ff; border: 1px solid #2a3a46; border-radius: 14px; box-shadow: 0 10px 40px rgba(0,0,0,.45); padding: 18px 20px; }
  .agent-card h3 { margin: 6px 0 10px; font-weight: 600; }
  .agent-card pre { white-space: pre-wrap; font-family: inherit; background: #0c1218; padding: 12px; border-radius: 10px; border: 1px solid #22313c; }
  .agent-actions { display:flex; gap: 10px; justify-content: flex-end; margin-top: 12px; }
  .agent-actions button { padding: 10px 12px; border-radius: 10px; border: 1px solid #2a3a46; background:#16222c; color:#d8ecff; cursor: pointer; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="800" aria-label="Simulador de Marchas"></canvas>
</div>
<div class="ai-tools">
  <button id="btnToggle" aria-pressed="true">Apoyo de agente: ON</button>
</div>
<div id="agentPanel" class="agent-panel">
  <div class="agent-card">
    <h3>Asesor de Conducci√≥n</h3>
    <div id="agentReason" style="color:#a6c8ff; font-size:14px; margin-bottom:8px"></div>
    <pre id="agentAdvice"></pre>
    <div class="agent-actions" style="justify-content:center; color:#9fc7ff">Pulsa Space para continuar</div>
  </div>
  
</div>
<div class="hud">
  Controles: W=Acelerador ¬∑ Space=Freno ¬∑ Shift=Embrague ¬∑
  Clic Izq (con Shift)=Subir ¬∑ Clic Der (con Shift)=Bajar ¬∑ N‚Üí1¬™=Shift+Space
</div>

<script>
/* ============================
   CONFIGURACI√ìN DEL MOTOR
   ============================ */
const cfg = {
  idleMin: 1000,            // rpm m√≠nimo al ralent√≠
  idleMax: 1500,            // rpm m√°ximo al ralent√≠ (arranque)
  optimalMin: 2500,         // ventana √≥ptima para upshift
  optimalMax: 3500,
  redline: 4500,            // aviso de zona roja (sobre-revoluci√≥n)
  hardMax: 5000,            // tope absoluto (clamp visual)
  accelPerSec: 15,          // ŒîRPM por segundo cuando se acelera (por tick)
  decayToIdleK: 0.5,        // rapidez con la que cae a ralent√≠ (por segundo)
  brakeK: 4.0,              // rapidez extra de ca√≠da al frenar
  // Relaciones de marcha (valores conceptuales; N==0 significa desacople)
  gears: [
    {name:'N', ratio: 0.00},
    {name:'1', ratio: 3.50},
    {name:'2', ratio: 2.20},
    {name:'3', ratio: 1.50},
    {name:'4', ratio: 1.10},
    {name:'5', ratio: 0.90},
  ],
};

/* ============================
   ESTADO DEL SIMULADOR
   ============================ */
const state = {
  gearIndex: 0,                      // arranca en Neutro
  rpm: lerp(cfg.idleMin, cfg.idleMax, 0.5),
  inputs: { w:false, shift:false, space:false, mouseL:false, mouseR:false },
  lastTime: performance.now(),
  agentMsgs: [],                     // cola de mensajes del ‚ÄúAgente‚Äù
  justHitOptimal: false,             // bandera para mensaje ‚ÄúMomento √≥ptimo‚Äù
  audio: { ctx:null, started:false, gain:null, osc1:null, osc2:null, filter:null }
};
// Estado del modo Agente
state.agent = {
  active: false,
  slowing: 0,           // 0..1 factor de pausa progresiva
  lastTrigger: 0,
  reason: '',
  apiKey: 'REEMPLAZA_CON_TU_API_KEY',
  metrics: { timeInNeutral:0, timeAboveRed:0, timeNoClutchAttempt:0 },
  enabled: true,
  history: [],          // buffer de √∫ltimas acciones
  cooldownMs: 15000,
};

/* ============================
   UTILITARIOS
   ============================ */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t){ return a + (b-a)*t; }
function map(v, a1, a2, b1, b2){ const t=(v-a1)/(a2-a1); return b1 + (b2-b1)*clamp(t,0,1); }
function now(){ return performance.now(); }

/* ============================
   MENSAJES DEL AGENTE
   ============================ */
function say(text, kind='info', ttl=1800){
  if(state.agent && state.agent.active) return; // suprimir cuando el agente est√© activo
  state.agentMsgs.push({ text, kind, born: now(), ttl });
}
function drawAgentMessages(ctx){
  if(state.agent && state.agent.active) return; // no mostrar mientras el agente ocupa la pantalla
  const baseY = 80;
  for(let i=state.agentMsgs.length-1, row=0; i>=0; i--, row++){
    const m = state.agentMsgs[i];
    const age = now()-m.born;
    const alive = age < m.ttl;
    if(!alive){ state.agentMsgs.splice(i,1); continue; }
    const alpha = age < 200 ? map(age,0,200,0,1) : map(age, m.ttl-300, m.ttl, 1, 0);
    ctx.save();
      ctx.globalAlpha = clamp(alpha,0,1);
      ctx.font = "20px system-ui, Segoe UI, Roboto, Arial";
      ctx.textAlign = "left"; ctx.textBaseline = "top";
      const color = m.kind==='warn' ? "#ffb4a9" : m.kind==='ok' ? "#c0ffd3" : "#e7f0ff";
      ctx.fillStyle = color;
      const pad = 12, maxw = 560;
      const metrics = ctx.measureText(m.text);
      const w = Math.min(maxw, metrics.width + pad*2);
      const h = 34;
      const x = 260, y = baseY + row*(h+10);
      // burbuja
      ctx.fillStyle = "rgba(20,25,32,0.85)";
      roundRect(ctx, x, y, w, h, 10); ctx.fill();
      // texto
      ctx.fillStyle = color;
      ctx.fillText(m.text, x+pad, y+8);
    ctx.restore();
  }
}
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

/* ============================
   ENTRADAS
   ============================ */
const KEY = { W:'KeyW', SHIFT:'ShiftLeft', SHIFT_R:'ShiftRight', SPACE:'Space' };

addEventListener('keydown', (e)=>{
  if(e.code===KEY.W) state.inputs.w = true;
  if(e.code===KEY.SPACE) state.inputs.space = true;
  if(e.code===KEY.SHIFT || e.code===KEY.SHIFT_R) state.inputs.shift = true;

  ensureAudio();

  // N -> 1¬™ requiere Shift + Space (pisar embrague y freno)
  if(state.gearIndex===0 && state.inputs.shift && state.inputs.space){
    state.gearIndex = 1;
    state.rpm = clamp(state.rpm, cfg.idleMin, cfg.idleMax);
    say("¬°Listo! Engranaste 1¬™ (embrague+freno).", "ok");
  }
});

addEventListener('keyup', (e)=>{
  if(e.code===KEY.W) state.inputs.w = false;
  if(e.code===KEY.SPACE) state.inputs.space = false;
  if(e.code===KEY.SHIFT || e.code===KEY.SHIFT_R) state.inputs.shift = false;
  // Reanudar con Space cuando el agente est√© activo
  if(e.code===KEY.SPACE && state.agent.active){
    endAgentSession();
  }
});

addEventListener('mousedown', (e)=>{
  // Evitar men√∫ contextual para usar clic derecho
  if(e.button===2) e.preventDefault();

  ensureAudio();

  // Cambios solo con Shift presionado
  if(!state.inputs.shift) return;

  const old = state.gearIndex;
  if(e.button===0){ // subir
    doUpshift();
  }else if(e.button===2){ // bajar
    doDownshift();
  }

  // si hubo cambio, suelta embrague ‚Äúvirtual‚Äù (no hay acople de veh√≠culo aqu√≠)
});
addEventListener('contextmenu', e=>e.preventDefault());

// Controles UI agente
const $btnToggle = () => document.getElementById('btnToggle');
const $panel = () => document.getElementById('agentPanel');
const $advice = () => document.getElementById('agentAdvice');
const $reason = () => document.getElementById('agentReason');
// botones eliminados

addEventListener('DOMContentLoaded', ()=>{
  $btnToggle().addEventListener('click', toggleAgent);
  state.agent.enabled = true; // ON por defecto
  $btnToggle().setAttribute('aria-pressed','true');
});

/* ============================
   L√ìGICA DE CAMBIOS
   ============================ */
function doUpshift(){
  if(state.gearIndex<=0){ say("Primero engrana 1¬™ (Shift+Space).", "warn"); return; }
  if(state.gearIndex >= cfg.gears.length-1){ say("Ya est√°s en la marcha m√°s alta.", "warn"); return; }

  // Validar ventana √≥ptima
  if(state.rpm < cfg.optimalMin){
    say("Necesitas m√°s potencia (sube RPM antes de cambiar).", "warn");
    return;
  }
  if(state.rpm > 4000){
    say("¬°Sobre-revoluci√≥n! Baja la aceleraci√≥n.", "warn");
    // permitimos el cambio, pero lo marcamos como no √≥ptimo
  }

  const oldGear = cfg.gears[state.gearIndex];
  state.gearIndex += 1;
  const newGear = cfg.gears[state.gearIndex];

  // Ajuste instant√°neo de RPM seg√∫n relaciones
  const ratio = (oldGear.ratio || 1) / (newGear.ratio || 1);
  state.rpm = clamp(state.rpm * ratio, cfg.idleMin, cfg.redline);
  say(`Subiste a ${newGear.name}¬™.`, (state.rpm>=cfg.optimalMin && state.rpm<=cfg.optimalMax)?'ok':'info');
}

function doDownshift(){
  if(state.gearIndex<=1){ // si est√°s en 1¬™ o N
    if(state.gearIndex===1){ state.gearIndex=0; say("Pasaste a Neutro (N).", "info"); }
    else say("Ya est√°s en Neutro.", "warn");
    return;
  }
  const oldGear = cfg.gears[state.gearIndex];
  state.gearIndex -= 1;
  const newGear = cfg.gears[state.gearIndex];

  // Ajuste de RPM hacia arriba por reducci√≥n
  const ratio = (oldGear.ratio || 1) / (newGear.ratio || 1);
  state.rpm = clamp(state.rpm / ratio, cfg.idleMin, cfg.hardMax);
  if(state.rpm > cfg.redline) say("Cuidado: reducci√≥n agresiva (RPM altas).", "warn");
  say(`Bajaste a ${newGear.name}¬™.`, "info");
}

/* ============================
   BUCLE PRINCIPAL
   ============================ */
const cvs = document.getElementById('game');
const ctx  = cvs.getContext('2d');

/* ============================
   AUDIO DEL MOTOR (WebAudio)
   ============================ */
function ensureAudio(){
  if(state.audio.started) return;
  try{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const ac = new AudioCtx();
    const osc1 = ac.createOscillator(); // tono fundamental (pulso motor)
    const osc2 = ac.createOscillator(); // arm√≥nico
    const filter = ac.createBiquadFilter();
    const gain = ac.createGain();

    osc1.type = 'sawtooth';
    osc2.type = 'square';
    filter.type = 'lowpass';
    filter.frequency.value = 1200;
    gain.gain.value = 0.0; // silencio inicial

    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(ac.destination);

    const t = ac.currentTime + 0.01;
    osc1.start(t);
    osc2.start(t);

    state.audio = { ctx: ac, started: true, gain, osc1, osc2, filter };
  }catch(err){
    // si falla, no bloqueamos el simulador
    state.audio.started = false;
  }
}

function updateAudio(){
  if(!state.audio.started) return;
  const { ctx:ac, gain, osc1, osc2, filter } = state.audio;

  // Frecuencia base proporcional a RPM (pulsos por revoluci√≥n aproximados)
  const baseHz = Math.max(28, (state.rpm/60) * 2);
  const tNow = ac.currentTime;
  if(osc1 && osc2){
    osc1.frequency.setTargetAtTime(baseHz, tNow, 0.03);
    osc2.frequency.setTargetAtTime(baseHz*2, tNow, 0.03);
  }

  // Intensidad y brillo seg√∫n acelerador y marcha engranada
  const throttle = state.inputs.w && state.gearIndex>0 ? 1 : 0;
  const idleLevel = 0.02;
  const driveLevel = 0.12;
  const targetGain = throttle ? driveLevel : idleLevel;
  if(gain){
    gain.gain.setTargetAtTime(targetGain, tNow, 0.08);
  }
  if(filter){
    const cut = throttle ? 2000 : 1200;
    filter.frequency.setTargetAtTime(cut, tNow, 0.08);
    filter.Q.setTargetAtTime(throttle ? 0.8 : 0.5, tNow, 0.08);
  }
}

function step(){
  const t = performance.now();
  const dt = Math.min(0.05, (t - state.lastTime) / 1000); // dt en segundos (clamp 50 ms)
  state.lastTime = t;

  // factor de pausa progresiva (1 = normal, 0 = detenido)
  const targetSlow = state.agent.active ? 1 : 0;
  state.agent.slowing += (targetSlow - state.agent.slowing) * 0.08;
  const simSpeed = Math.max(0, 1 - state.agent.slowing);
  const dtEff = dt * simSpeed;

  // 1) F√≠sica sencilla de RPM
  const targetIdle = lerp(cfg.idleMin, cfg.idleMax, 0.35);
  let rpm = state.rpm;

  if(state.gearIndex>0 && state.inputs.w){
    rpm += cfg.accelPerSec * dtEff * 100;  // amplifica el efecto para hacerlo visible
  } else {
    // cae hacia ralent√≠
    const k = state.inputs.space ? (cfg.decayToIdleK + cfg.brakeK) : cfg.decayToIdleK;
    rpm += (targetIdle - rpm) * k * dtEff;
  }

  // l√≠mites
  rpm = clamp(rpm, cfg.idleMin*0.8, cfg.hardMax);
  state.rpm = rpm;

  // 2) Se√±al ‚Äúmomento √≥ptimo‚Äù (desactivada durante agente)
  const inOptimal = (rpm >= cfg.optimalMin && rpm <= cfg.optimalMax && state.gearIndex>0 && state.gearIndex<cfg.gears.length-1);
  if(!state.agent.active && inOptimal && !state.justHitOptimal){
    say("¬°Momento √≥ptimo! Mant√©n embrague (Shift) y clic izquierdo para subir marcha.", "ok", 2400);
    state.justHitOptimal = true;
  }
  if(!inOptimal) state.justHitOptimal = false;

  // 2b) M√©tricas para detecci√≥n de coaching
  updateCoachingMetrics(dtEff);
  maybeTriggerAgent();

  // 3) Render
  render();

  // 4) Audio
  updateAudio();

  requestAnimationFrame(step);
}

requestAnimationFrame(step);

/* ============================
   RENDER
   ============================ */
function render(){
  const w = cvs.width, h = cvs.height;

  // FONDO base
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#0a0e12";
  ctx.fillRect(0,0,w,h);

  // Interior del coche (parabrisas, pilares y tablero)
  drawCabin(ctx);

  // === Met√°fora 1: ‚ÄúM√°s Luz, M√°s Velocidad‚Äù
  // brillo proporcional a RPM; elevamos luminancia con un overlay blanco transl√∫cido
  const brightT = map(state.rpm, cfg.idleMin, cfg.redline, 0.05, 0.38);
  ctx.save();
    ctx.globalAlpha = brightT;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,w,h);
  ctx.restore();

  // === Barra de progreso vertical (cohete)
  drawRocketBar(ctx);

  // === Volante y Tablero (solo visual)
  drawSteeringWheel(ctx);
  drawInstrumentCluster(ctx);

  // === Tablero/HUD (donde puedes integrar los artefactos visuales del boceto)
  drawDashboard(ctx);

  // === Pedales (Embrague-Shift, Freno-Space, Acelerador-W)
  drawPedals(ctx);

  // === Mensajes del Agente
  drawAgentMessages(ctx);

  // === Comentarios para integrar UI del boceto ===
  // - Sustituye drawSteeringWheel() por im√°genes SVG/PNG del volante/tablero.
  // - Reemplaza drawGearStickHint() por tu arte de palanca y animaciones.
  // - En drawRocketBar() puedes usar sprites: cohete, planeta/galaxia y barra.
}

/* ----- HUD principal: RPM, marcha y tips ----- */
function drawDashboard(ctx){
  const pad = 20;

  // Cartela superior derecha con RPM
  const rpmText = `Revoluciones: ${(state.rpm/1000).toFixed(1)} x 1000 rpm`;
  ctx.save();
    ctx.font = "20px system-ui, Segoe UI, Roboto, Arial";
    ctx.textAlign = "right"; ctx.textBaseline = "top";
    const tw = ctx.measureText(rpmText).width;
    const rpmBx = cvs.width - pad - tw - 30, rpmBy = pad, rpmBw = tw + 30, rpmBh = 38;
    ctx.fillStyle = "rgba(24,44,52,0.85)";
    roundRect(ctx, rpmBx, rpmBy, rpmBw, rpmBh, 14); ctx.fill();
    ctx.fillStyle = "#e5f6ff";
    ctx.fillText(rpmText, cvs.width - pad - 16, rpmBy+9);
  ctx.restore();

  // Caja inferior con estado de marcha y controles
  const gear = cfg.gears[state.gearIndex].name;
  const status = `Marcha: ${gear}    ${state.inputs.shift?'[Embrague: ON]':'[Embrague: OFF]'}    ${state.inputs.w?'[Acelerando]':''} ${state.inputs.space?'[Frenando]':''}`;
  ctx.save();
    ctx.font = "18px system-ui, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillStyle = "rgba(24,44,52,0.85)";
    const statusBw = 720, statusBh = 44, statusBx = (cvs.width-statusBw)/2, statusBy = cvs.height-20-statusBh;
    roundRect(ctx, statusBx, statusBy, statusBw, statusBh, 12); ctx.fill();
    ctx.fillStyle = "#d8ecff";
    ctx.fillText(status, cvs.width/2, statusBy+statusBh-12);
  ctx.restore();

  // Hint de palanca (clic izq/der + Shift)
  drawGearStickHint(ctx);
}

/* ----- Interior del coche (parabrisas/pilares/tablero superior) ----- */
function drawCabin(ctx){
  const w = cvs.width, h = cvs.height;
  ctx.save();
    // Parabrisas degradado
    const sky = ctx.createLinearGradient(0,0,0,h*0.5);
    sky.addColorStop(0, "#0e1520");
    sky.addColorStop(1, "#0a0e12");
    ctx.fillStyle = sky;
    ctx.beginPath();
    ctx.moveTo(80, 40);
    ctx.quadraticCurveTo(w/2, 10, w-80, 40);
    ctx.lineTo(w-60, h*0.42);
    ctx.quadraticCurveTo(w/2, h*0.48, 60, h*0.42);
    ctx.closePath();
    ctx.fill();

    // Pilares A izquierdo/derecho
    ctx.fillStyle = "#1a2129";
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(120,0); ctx.lineTo(80,220); ctx.lineTo(0,260); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(w,0); ctx.lineTo(w-120,0); ctx.lineTo(w-80,220); ctx.lineTo(w,260); ctx.closePath(); ctx.fill();

}

/* ----- Pedales con feedback visual ----- */
function drawPedals(ctx){
  const areaW = 520;
  const areaH = 160;
  const baseY = cvs.height - 80 - areaH;
  const baseX = (cvs.width - areaW)/2;

  const pedals = [
    { key:'shift', label:'Shift', x: baseX,          w: 150 }, // Embrague
    { key:'space', label:'Space', x: baseX + 185,    w: 150 }, // Freno
    { key:'w',     label:'W',     x: baseX + 370,    w: 150 }, // Acelerador
  ];

  pedals.forEach((p, i)=>{
    const pressed = !!state.inputs[p.key];
    const y = baseY + (pressed ? 10 : 0);
    const h = areaH - (pressed ? 16 : 0);
    ctx.save();
      // Sombra
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(ctx, p.x+6, baseY+areaH-10, p.w-12, 10, 6); ctx.fill();
      ctx.globalAlpha = 1;

      // Cuerpo del pedal
      const grad = ctx.createLinearGradient(p.x, y, p.x, y+h);
      grad.addColorStop(0, pressed?"#9fc7ff":"#d3e4f7");
      grad.addColorStop(1, pressed?"#7ca7e6":"#bcd3ea");
      ctx.fillStyle = grad;
      roundRect(ctx, p.x, y, p.w, h, 14); ctx.fill();

      // Borde
      ctx.strokeStyle = pressed?"#5e85b8":"#7f9fbf";
      ctx.lineWidth = 2;
      roundRect(ctx, p.x, y, p.w, h, 14); ctx.stroke();

      // Etiqueta
      ctx.fillStyle = "#10202a";
      ctx.font = "22px system-ui";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(p.label, p.x + p.w/2, y + h/2);
    ctx.restore();
  });

  ctx.save();
    ctx.fillStyle = "rgba(220,235,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText("Pedal Embrague (Shift)", cvs.width/2.8, baseY - 0.1);
  ctx.restore();

  ctx.save();
    ctx.fillStyle = "rgba(220,235,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText("Pedal Freno (Space)", cvs.width/2, baseY - 0.1);
  ctx.restore();

  ctx.save();
    ctx.fillStyle = "rgba(220,235,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText("Pedal Acelerador (W)", cvs.width/1.55, baseY - 0.1);
  ctx.restore();
  
}

function drawGearStickHint(ctx){
  ctx.save();
    const x = cvs.width - 220, y = cvs.height - 220;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(ctx, x, y, 200, 140, 14); ctx.fill();

    ctx.font = "14px system-ui, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "#c9d9ff";
    ctx.textAlign = "left"; ctx.textBaseline = "top";
    ctx.fillText("Cambios (mant√©n Shift):", x+12, y+10);
    ctx.fillText("‚Ä¢ Clic Izq: Subir marcha", x+12, y+36);
    ctx.fillText("‚Ä¢ Clic Der: Bajar marcha", x+12, y+58);
    ctx.fillText("N ‚Üí 1¬™: Shift + Space", x+12, y+92);
  ctx.restore();
}

/* ----- Met√°fora 2: Cohete/Galaxia (progreso RPM) ----- */
function drawRocketBar(ctx){
  const bar = { x: 40, y: 80, w: 46, h: cvs.height - 160, r: 16 };
  // Barra contenedor
  ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    roundRect(ctx, bar.x, bar.y, bar.w, bar.h, bar.r); ctx.fill();

    // Planeta/galaxia: marca del umbral √≥ptimo (entre 2500-3500 rpm).
    const tOpt = map(state.rpm, cfg.idleMin, cfg.redline, 0, 1); // no usado para la posici√≥n del planeta
    const optMid = (cfg.optimalMin + cfg.optimalMax)/2;
    const optY = map(optMid, cfg.idleMin, cfg.redline, bar.y+bar.h-24, bar.y+24);

    // L√≠nea/‚Äúplaneta‚Äù objetivo
    ctx.beginPath();
    ctx.arc(bar.x + bar.w/2, optY, 14, 0, Math.PI*2);
    ctx.fillStyle = "rgba(80,180,255,0.25)";
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#4ac0ff";
    ctx.stroke();

    // Zona √≥ptima (banda)
    const optY1 = map(cfg.optimalMax, cfg.idleMin, cfg.redline, bar.y+bar.h, bar.y);
    const optY2 = map(cfg.optimalMin, cfg.idleMin, cfg.redline, bar.y+bar.h, bar.y);
    ctx.fillStyle = "rgba(74,192,255,0.12)";
    ctx.fillRect(bar.x+6, optY1, bar.w-12, Math.max(6, optY2-optY1));

    // Progreso del cohete seg√∫n RPM
    const t = map(state.rpm, cfg.idleMin, cfg.redline, 0, 1);
    const rocketY = map(state.rpm, cfg.idleMin, cfg.redline, bar.y+bar.h-20, bar.y+20);

    // ‚ÄúCombustible‚Äù (relleno)
    ctx.fillStyle = "linear-gradient(#fff,#fff)"; // placeholder
    ctx.fillStyle = "rgba(74,192,255,0.35)";
    const fillTop = rocketY;
    roundRect(ctx, bar.x+10, fillTop, bar.w-20, bar.y+bar.h - fillTop, 8); ctx.fill();

    // Cohete (placeholder vectorial; aqu√≠ puedes colocar tu sprite PNG/SVG)
    drawRocketIcon(ctx, bar.x + bar.w/2, rocketY);

    // Marcas de escala
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 1;
    const steps = 6;
    for(let i=0;i<=steps;i++){
      const yy = map(i/steps, 0,1, bar.y+bar.h, bar.y);
      ctx.beginPath(); ctx.moveTo(bar.x+bar.w+6, yy); ctx.lineTo(bar.x+bar.w+18, yy); ctx.stroke();
      const rpmMark = Math.round(lerp(cfg.idleMin, cfg.redline, i/steps)/100)*100;
      ctx.fillStyle = "rgba(220,235,255,0.6)";
      ctx.font = "12px system-ui"; ctx.textAlign = "left"; ctx.textBaseline = "middle";
      ctx.fillText(`${(rpmMark/1000).toFixed(1)}k`, bar.x+bar.w+22, yy);
    }
  ctx.restore();
}

/* ----- Volante (visual, centrado) ----- */
function drawSteeringWheel(ctx){
  const size = 280;
  const pad = 28;
  const x = cvs.width/2;
  const y = cvs.height/2.1;

  ctx.save();
    // contenedor suave
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(ctx, x - size/2 - 8, y - size/2 - 8, size + 16, size + 16, 14); ctx.fill();

    const outerR = size/2;        // aro exterior
    const innerR = outerR * 0.78; // aro interior

    // aro exterior (tono marfil)
    ctx.fillStyle = "#e9e2d4";
    ctx.beginPath();
    ctx.arc(x,y, outerR, 0, Math.PI*2);
    ctx.arc(x,y, outerR-14, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(40,40,40,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x,y, outerR-7, 0, Math.PI*2); ctx.stroke();

    // aro interior (metal pulido)
    const metal = ctx.createLinearGradient(x-innerR, y-innerR, x+innerR, y+innerR);
    metal.addColorStop(0, "#9fb3bf");
    metal.addColorStop(0.5, "#c7d6df");
    metal.addColorStop(1, "#90a3ae");
    ctx.fillStyle = metal;
    ctx.beginPath();
    ctx.arc(x,y, innerR, 0, Math.PI*2);
    ctx.arc(x,y, innerR-10, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.fill();

    // centro con emblema de 3 puntas
    const hubR = innerR*0.46;
    ctx.fillStyle = "#1f2a33";
    ctx.beginPath(); ctx.arc(x,y, hubR+6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#dbe9f3";
    ctx.beginPath(); ctx.arc(x,y, hubR, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#97aebe";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x,y, hubR, 0, Math.PI*2); ctx.stroke();

    // estrella de tres puntas simplificada
    const starR = hubR*0.86;
    ctx.strokeStyle = "#32505f";
    ctx.lineWidth = 3;
    for(let i=0;i<3;i++){
      const a = -Math.PI/2 + i*(2*Math.PI/3);
      const px = x + Math.cos(a)* starR;
      const py = y + Math.sin(a)* starR;
      ctx.beginPath();
      ctx.moveTo(x,y); ctx.lineTo(px,py); ctx.stroke();
    }
    ctx.strokeStyle = "#7fa4b6";
    ctx.lineWidth = 1.6;
    ctx.beginPath(); ctx.arc(x,y, starR, 0, Math.PI*2); ctx.stroke();
  ctx.restore();
}

/* ----- Tablero / Instrument Cluster (visual, zona superior central) ----- */
function drawInstrumentCluster(ctx){
  const clusterW = 320;
  const clusterH = 160;
  const x = (cvs.width - clusterW)/2;
  const y = 72;

  ctx.save();
    // contenedor
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(ctx, x, y, clusterW, clusterH, 16); ctx.fill();

    // tac√≥metro circular a la izquierda
    const cx = x + 110;
    const cy = y + clusterH/2 + 10;
    const rOuter = 62;
    const rInner = 50;

    // fondo
    ctx.fillStyle = "#152027";
    ctx.beginPath(); ctx.arc(cx,cy,rOuter,0,Math.PI*2); ctx.fill();

    // arco de zona √≥ptima
    const aStart = Math.PI*1.2; // -144¬∞
    const aEnd   = Math.PI*1.95; // ~+171¬∞
    const optT1 = (cfg.optimalMin - cfg.idleMin) / (cfg.redline - cfg.idleMin);
    const optT2 = (cfg.optimalMax - cfg.idleMin) / (cfg.redline - cfg.idleMin);
    const optA1 = aStart + (aEnd-aStart)*optT1;
    const optA2 = aStart + (aEnd-aStart)*optT2;
    ctx.strokeStyle = "rgba(74,192,255,0.45)";
    ctx.lineWidth = 10;
    ctx.beginPath(); ctx.arc(cx,cy,rInner, optA1, optA2); ctx.stroke();

    // marcas
    ctx.strokeStyle = "rgba(220,235,255,0.5)";
    ctx.lineWidth = 2;
    const marks = 6;
    for(let i=0;i<=marks;i++){
      const t = i/marks;
      const a = aStart + (aEnd-aStart)*t;
      const x1 = cx + Math.cos(a)* (rInner-8);
      const y1 = cy + Math.sin(a)* (rInner-8);
      const x2 = cx + Math.cos(a)* (rInner+8);
      const y2 = cy + Math.sin(a)* (rInner+8);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.fillStyle = "rgba(220,235,255,0.7)";
      ctx.font = "12px system-ui"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
      const lx = cx + Math.cos(a)* (rInner+20);
      const ly = cy + Math.sin(a)* (rInner+20);
      const rpmMark = lerp(cfg.idleMin, cfg.redline, t)/1000;
      ctx.fillText(`${rpmMark.toFixed(1)}k`, lx, ly);
    }

    // aguja seg√∫n RPM
    const tRpm = (state.rpm - cfg.idleMin) / (cfg.redline - cfg.idleMin);
    const aNeedle = aStart + (aEnd-aStart) * clamp(tRpm,0,1);
    const nx = cx + Math.cos(aNeedle)* (rInner+2);
    const ny = cy + Math.sin(aNeedle)* (rInner+2);
    ctx.strokeStyle = "#ffb47a";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
    ctx.fillStyle = "#e9f6ff";
    ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill();

    // cuadro informativo a la derecha (marcha actual)
    const gear = cfg.gears[state.gearIndex].name;
    const bx = x + 200, by = y + 30, bw = 96, bh = 96;
    ctx.fillStyle = "rgba(24,44,52,0.85)";
    roundRect(ctx, bx, by, bw, bh, 12); ctx.fill();
    ctx.fillStyle = "#cfe6ff";
    ctx.font = "14px system-ui"; ctx.textAlign = "center"; ctx.textBaseline = "top";
    ctx.fillText("Marcha", bx + bw/2, by + 8);
    ctx.font = "46px system-ui"; ctx.textBaseline = "middle";
    ctx.fillText(gear, bx + bw/2, by + bh/2 + 6);
  ctx.restore();
}

function drawRocketIcon(ctx, cx, cy){
  ctx.save();
    ctx.translate(cx, cy);
    // cuerpo
    ctx.fillStyle = "#bfe6ff";
    ctx.beginPath();
    ctx.moveTo(0,-12);
    ctx.quadraticCurveTo(10,-2, 8,10);
    ctx.lineTo(-8,10);
    ctx.quadraticCurveTo(-10,-2, 0,-12);
    ctx.fill();

    // ventanilla
    ctx.beginPath();
    ctx.arc(0,-4,4,0,Math.PI*2);
    ctx.fillStyle = "#203040";
    ctx.fill();

    // llama
    ctx.beginPath();
    ctx.moveTo(0,14);
    ctx.lineTo(5,22);
    ctx.lineTo(-5,22);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,180,120,0.9)";
    ctx.fill();
  ctx.restore();
}

/* ============================
   DETECCI√ìN Y SESI√ìN DEL AGENTE
   ============================ */
function updateCoachingMetrics(dt){
  if(state.gearIndex===0) state.agent.metrics.timeInNeutral += dt; else state.agent.metrics.timeInNeutral = 0;
  if(state.rpm > cfg.redline*0.93) state.agent.metrics.timeAboveRed += dt; else state.agent.metrics.timeAboveRed = 0;
  if(!state.inputs.shift && state.inputs.w && state.gearIndex>0) state.agent.metrics.timeNoClutchAttempt += dt; else state.agent.metrics.timeNoClutchAttempt = 0;
  pushHistoryTick();
}

function detectCoachingReason(){
  if(state.agent.metrics.timeInNeutral > 8) return 'Mucho tiempo en Neutro. Practicar arranque: embrague + freno, luego acelera suave.';
  if(state.agent.metrics.timeAboveRed > 2) return 'RPM muy altas cerca de la zona roja. Sube de marcha dentro del rango √≥ptimo (2.5k-3.5k).';
  if(state.agent.metrics.timeNoClutchAttempt > 5) return 'Aceleras sin usar embrague. Coordina embrague (Shift) con aceleraci√≥n para transiciones suaves.';
  return '';
}

function maybeTriggerAgent(){
  if(!state.agent.enabled || state.agent.active) return;
  const reason = detectCoachingReason();
  if(!reason) return;
  const nowMs = now();
  if(nowMs - state.agent.lastTrigger < state.agent.cooldownMs) return; // cooldown
  startAgentSession(reason);
}

async function startAgentSession(reason){
  state.agent.active = true;
  state.agent.reason = reason || 'Asesoramiento del sistema';
  state.agent.lastTrigger = now();
  $reason().textContent = 'Motivo: ' + state.agent.reason;
  $advice().textContent = 'Analizando tu conducci√≥n y consultando al agente...';
  $panel().style.display = 'flex';

  const snapshot = buildAgentSnapshot();
  const key = (state.agent.apiKey || '').trim();
  if(!key){
    $advice().textContent = localFallbackAdvice(snapshot);
    return;
  }
  try{
    await delay(700 + Math.random()*500); // peque√±o retardo intencional
    const text = await fetchGeminiAdvice(key, snapshot);
    $advice().textContent = text || localFallbackAdvice(snapshot);
  }catch(err){
    $advice().textContent = localFallbackAdvice(snapshot) + '\n\n[Nota: no se pudo contactar a Gemini]';
  }
}

function endAgentSession(){
  state.agent.active = false;
  $panel().style.display = 'none';
  $btnResume().style.display = 'none';
  $coachStatus().textContent = '';
  state.agent.reason = '';
}

function buildAgentSnapshot(){
  return {
    rpm: Math.round(state.rpm),
    gear: cfg.gears[state.gearIndex].name,
    inputs: { accelerating: !!state.inputs.w, braking: !!state.inputs.space, clutch: !!state.inputs.shift },
    optimalRange: { min: cfg.optimalMin, max: cfg.optimalMax },
    redline: cfg.redline,
    reason: state.agent.reason,
    history: state.agent.history.slice(-20),
    action: inferDriverAction(),
    intendedChange: inferIntendedChange(),
    pedalsPct: estimatePedalsPct()
  };
}

function localFallbackAdvice(s){
  return (
    `Consejo t√©cnico:\n- Marcha: ${s.gear}. RPM: ${s.rpm}. Rango √≥ptimo: ${s.optimalRange.min}-${s.optimalRange.max}.\n`+
    `Recomendaci√≥n pr√°ctica:\n- ${state.agent.reason}\n- Practica coordinando embrague (Shift) y acelerador (W).\n`+
    `Motivaci√≥n:\n- Paso a paso. Cada intento mejora tu sensibilidad y control. üí™`
  );
}

async function fetchGeminiAdvice(apiKey, snapshot){
  const prompt = buildGeminiPrompt(snapshot);
  const body = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      temperature: 0.6,
      maxOutputTokens: 350,
    }
  };
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(apiKey)}`;
  const res = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body) });
  if(!res.ok) throw new Error('Gemini API error');
  const json = await res.json();
  const text = json?.candidates?.[0]?.content?.parts?.[0]?.text || '';
  return sanitizeGeminiText(text);
}

function buildGeminiPrompt(s){
  return [
    'Act√∫a como un copiloto de conducci√≥n experimentado, paciente y amigable.',
    '',
    'Objetivo: Proporcionar consejos o correcciones inmediatas, junto con una justificaci√≥n te√≥rica simple, sobre la maniobra de conducci√≥n manual que se est√° realizando en tiempo real.',
    '',
    'Definici√≥n de Agente de Conducci√≥n Manual: Soy un sistema (agente) que monitoriza las interacciones del conductor humano con el veh√≠culo. Mi prop√≥sito es analizar estas acciones (cambio de marcha, uso de pedales, revoluciones) para evaluar la t√©cnica y ofrecer feedback constructivo que mejore la eficiencia, seguridad y suavidad de la conducci√≥n.',
    '',
    'Datos Actuales de la Maniobra:',
    `- Acci√≥n del conductor: ${s.action}`,
    `- Marcha Actual: ${s.gear}.`,
    `- Cambio Solicitado/Previsto: ${s.intendedChange}.`,
    `- Revoluciones (RPM): ${s.rpm} RPM.`,
    `- Pedales (estado/uso): Freno: ${s.pedalsPct.brake}% pisado, Clutch: ${s.pedalsPct.clutch}% pisado, Acelerador: ${s.pedalsPct.throttle}% pisado.`,
    '',
    'Tarea: Analiza los datos de la maniobra e inmediatamente proporciona:',
    '1. Consejo/Correcci√≥n: Una frase clara y directa sobre qu√© hacer (ej: "Sube la marcha ahora" o "Disminuye la presi√≥n del embrague").',
    '2. Justificaci√≥n Te√≥rica Amigable: Una explicaci√≥n concisa y f√°cil de entender del por qu√© de la correcci√≥n, enfocada en la seguridad, la eficiencia del combustible o el cuidado mec√°nico del veh√≠culo (ej: "Esto evitar√° que el motor se revolucione demasiado, lo que es mejor para el consumo y el desgaste").',
    '',
    'Formato de Salida:',
    '¬°ALERTA DE CONDUCCI√ìN!\nConsejo: <tu consejo/correcci√≥n>\nPor qu√©: <justificaci√≥n te√≥rica>'
  ].join('\n');
}

function sanitizeGeminiText(t){
  return String(t||'')
    .replace(/```[\s\S]*?```/g, '')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

function toggleAgent(){
  state.agent.enabled = !state.agent.enabled;
  const on = state.agent.enabled;
  $btnToggle().textContent = `Apoyo de agente: ${on?'ON':'OFF'}`;
  $btnToggle().setAttribute('aria-pressed', on?'true':'false');
}

function pushHistoryTick(){
  const entry = {
    t: Math.round(performance.now()),
    rpm: Math.round(state.rpm),
    gear: cfg.gears[state.gearIndex].name,
    inputs: { w: !!state.inputs.w, space: !!state.inputs.space, shift: !!state.inputs.shift },
    type: classifyActionType(),
    detail: actionDetailString()
  };
  state.agent.history.push(entry);
  if(state.agent.history.length>120) state.agent.history.shift();
}

function classifyActionType(){
  if(state.gearIndex===0 && state.inputs.w) return 'acel_neutro';
  if(state.inputs.w && !state.inputs.shift && state.gearIndex>0) return 'acel_sin_embrague';
  if(state.rpm>cfg.redline*0.93) return 'rpm_altas';
  if(state.inputs.space) return 'frenando';
  if(state.inputs.shift) return 'embrague';
  return 'normal';
}

function actionDetailString(){
  return `rpm=${Math.round(state.rpm)}, gear=${cfg.gears[state.gearIndex].name}, W=${!!state.inputs.w}, Space=${!!state.inputs.space}, Shift=${!!state.inputs.shift}`;
}

function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

function inferDriverAction(){
  const last = state.agent.history[state.agent.history.length-1];
  if(!last) return 'Observando la marcha y las RPM.';
  switch(last.type){
    case 'acel_neutro': return 'Acelerando en Neutro.';
    case 'acel_sin_embrague': return 'Acelerando sin usar embrague en marcha engranada.';
    case 'rpm_altas': return 'Manteniendo RPM altas cerca de zona roja.';
    case 'frenando': return 'Frenando.';
    case 'embrague': return 'Usando el embrague.';
    default: return 'Conducci√≥n normal sin cambios recientes.';
  }
}

function inferIntendedChange(){
  // Heur√≠stica simple: si RPM altas y en marcha < 5, sugiere subir; si en Neutro y freno+embrague, sugiere iniciar en 1¬™
  const gearIdx = state.gearIndex;
  if(gearIdx===0){
    if(state.inputs.shift && state.inputs.space) return 'Iniciar movimiento: subir a 1¬™';
    return 'Mantener en Neutro';
  }
  if(state.rpm > cfg.optimalMax && gearIdx < cfg.gears.length-1) return `Subir a ${cfg.gears[gearIdx+1].name}¬™`;
  if(state.rpm < cfg.optimalMin && gearIdx > 1) return `Bajar a ${cfg.gears[gearIdx-1].name}¬™`;
  return 'Mantener';
}

function estimatePedalsPct(){
  // Como no hay presi√≥n anal√≥gica real, mapear booleanos a 0/100 y freno suave si cae a ralent√≠ con Space
  const throttle = state.inputs.w ? 100 : 0;
  const brake = state.inputs.space ? 25 : 0; // aproximaci√≥n visual
  const clutch = state.inputs.shift ? 100 : 0;
  return { throttle, brake, clutch };
}


</script>
</body>
</html>
