<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulador Conceptual: Cambio de Marchas</title>
<style>
  html, body { height: 100%; margin: 0; background:#0f1418; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; }
  #wrap { height: 100%; display: grid; place-items: center; }
  canvas { border-radius: 14px; box-shadow: 0 10px 40px rgba(0,0,0,.35); background:#0a0e12; }
  .hud { position: fixed; left: 16px; bottom: 50px; color:#d6e6ff; font-size: 20px; opacity:.6 }
  .ai-tools { position: fixed; right: 16px; top: 16px; display: flex; gap: 8px; align-items: center; }
  .ai-tools button { padding: 8px 12px; border-radius: 8px; border: 1px solid #2a3a46; background:#14202a; color:#d8ecff; cursor: pointer; }
  .agent-panel { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(5,8,12,0.72); }
  .agent-card { width: 720px; max-width: calc(100% - 40px); background: #10161d; color:#e8f2ff; border: 1px solid #2a3a46; border-radius: 14px; box-shadow: 0 10px 40px rgba(0,0,0,.45); padding: 18px 20px; }
  .agent-card h3 { margin: 6px 0 10px; font-weight: 600; }
  .agent-card pre { white-space: pre-wrap; font-family: inherit; background: #0c1218; padding: 12px; border-radius: 10px; border: 1px solid #22313c; }
  .agent-actions { display:flex; gap: 10px; justify-content: flex-end; margin-top: 12px; }
  .agent-actions button { padding: 10px 12px; border-radius: 10px; border: 1px solid #2a3a46; background:#16222c; color:#d8ecff; cursor: pointer; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="800" aria-label="Simulador de Marchas"></canvas>
</div>
<div class="ai-tools">
  <button id="btnToggle" aria-pressed="true">Apoyo de agente: ON</button>
</div>
<div id="agentPanel" class="agent-panel">
  <div class="agent-card">
    <h3>Asesor de Conducción</h3>
    <div id="agentReason" style="color:#a6c8ff; font-size:14px; margin-bottom:8px"></div>
    <pre id="agentAdvice"></pre>
    <div class="agent-actions" style="justify-content:center; color:#9fc7ff">Pulsa Space para continuar</div>
  </div>
  
</div>
<div class="hud">
  Controles: W=Acelerador · Space=Freno · Shift=Embrague ·
  Clic Izq (con Shift)=Subir · Clic Der (con Shift)=Bajar · N→1ª=Shift+Space
</div>

<script>
/* ============================
   CONFIGURACIÓN DEL MOTOR
   ============================ */
const cfg = {
  idleMin: 1000,            // rpm mínimo al ralentí
  idleMax: 1500,            // rpm máximo al ralentí (arranque)
  optimalMin: 2500,         // ventana óptima para upshift
  optimalMax: 3500,
  redline: 4500,            // aviso de zona roja (sobre-revolución)
  hardMax: 5000,            // tope absoluto (clamp visual)
  accelPerSec: 15,          // ΔRPM por segundo cuando se acelera (por tick)
  decayToIdleK: 0.5,        // rapidez con la que cae a ralentí (por segundo)
  brakeK: 4.0,              // rapidez extra de caída al frenar
  // Relaciones de marcha (valores conceptuales; N==0 significa desacople)
  gears: [
    {name:'N', ratio: 0.00},
    {name:'1', ratio: 3.50},
    {name:'2', ratio: 2.20},
    {name:'3', ratio: 1.50},
    {name:'4', ratio: 1.10},
    {name:'5', ratio: 0.90},
  ],
};

/* ============================
   ESTADO DEL SIMULADOR
   ============================ */
const state = {
  gearIndex: 0,                      // arranca en Neutro
  rpm: lerp(cfg.idleMin, cfg.idleMax, 0.5),
  inputs: { w:false, shift:false, space:false, mouseL:false, mouseR:false },
  lastTime: performance.now(),
  agentMsgs: [],                     // cola de mensajes del “Agente”
  justHitOptimal: false,             // bandera para mensaje “Momento óptimo”
  audio: { ctx:null, started:false, gain:null, osc1:null, osc2:null, filter:null }
};
// Estado del modo Agente
state.agent = {
  active: false,
  slowing: 0,           // 0..1 factor de pausa progresiva
  lastTrigger: 0,
  reason: '',
  apiKey: 'REEMPLAZA_CON_TU_API_KEY',
  metrics: { timeInNeutral:0, timeAboveRed:0, timeNoClutchAttempt:0 },
  enabled: true,
  history: [],          // buffer de últimas acciones
  cooldownMs: 15000,
};

/* ============================
   UTILITARIOS
   ============================ */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t){ return a + (b-a)*t; }
function map(v, a1, a2, b1, b2){ const t=(v-a1)/(a2-a1); return b1 + (b2-b1)*clamp(t,0,1); }
function now(){ return performance.now(); }

/* ============================
   MENSAJES DEL AGENTE
   ============================ */
function say(text, kind='info', ttl=1800){
  if(state.agent && state.agent.active) return; // suprimir cuando el agente esté activo
  state.agentMsgs.push({ text, kind, born: now(), ttl });
}
function drawAgentMessages(ctx){
  if(state.agent && state.agent.active) return; // no mostrar mientras el agente ocupa la pantalla
  const baseY = 80;
  for(let i=state.agentMsgs.length-1, row=0; i>=0; i--, row++){
    const m = state.agentMsgs[i];
    const age = now()-m.born;
    const alive = age < m.ttl;
    if(!alive){ state.agentMsgs.splice(i,1); continue; }
    const alpha = age < 200 ? map(age,0,200,0,1) : map(age, m.ttl-300, m.ttl, 1, 0);
    ctx.save();
      ctx.globalAlpha = clamp(alpha,0,1);
      ctx.font = "20px system-ui, Segoe UI, Roboto, Arial";
      ctx.textAlign = "left"; ctx.textBaseline = "top";
      const color = m.kind==='warn' ? "#ffb4a9" : m.kind==='ok' ? "#c0ffd3" : "#e7f0ff";
      ctx.fillStyle = color;
      const pad = 12, maxw = 560;
      const metrics = ctx.measureText(m.text);
      const w = Math.min(maxw, metrics.width + pad*2);
      const h = 34;
      const x = 260, y = baseY + row*(h+10);
      // burbuja
      ctx.fillStyle = "rgba(20,25,32,0.85)";
      roundRect(ctx, x, y, w, h, 10); ctx.fill();
      // texto
      ctx.fillStyle = color;
      ctx.fillText(m.text, x+pad, y+8);
    ctx.restore();
  }
}
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

/* ============================
   ENTRADAS
   ============================ */
const KEY = { W:'KeyW', SHIFT:'ShiftLeft', SHIFT_R:'ShiftRight', SPACE:'Space' };

addEventListener('keydown', (e)=>{
  if(e.code===KEY.W) state.inputs.w = true;
  if(e.code===KEY.SPACE) state.inputs.space = true;
  if(e.code===KEY.SHIFT || e.code===KEY.SHIFT_R) state.inputs.shift = true;

  ensureAudio();

  // N -> 1ª requiere Shift + Space (pisar embrague y freno)
  if(state.gearIndex===0 && state.inputs.shift && state.inputs.space){
    state.gearIndex = 1;
    state.rpm = clamp(state.rpm, cfg.idleMin, cfg.idleMax);
    say("¡Listo! Engranaste 1ª (embrague+freno).", "ok");
  }
});

addEventListener('keyup', (e)=>{
  if(e.code===KEY.W) state.inputs.w = false;
  if(e.code===KEY.SPACE) state.inputs.space = false;
  if(e.code===KEY.SHIFT || e.code===KEY.SHIFT_R) state.inputs.shift = false;
  // Reanudar con Space cuando el agente esté activo
  if(e.code===KEY.SPACE && state.agent.active){
    endAgentSession();
  }
});

addEventListener('mousedown', (e)=>{
  // Evitar menú contextual para usar clic derecho
  if(e.button===2) e.preventDefault();

  ensureAudio();

  // Cambios solo con Shift presionado
  if(!state.inputs.shift) return;

  const old = state.gearIndex;
  if(e.button===0){ // subir
    doUpshift();
  }else if(e.button===2){ // bajar
    doDownshift();
  }

  // si hubo cambio, suelta embrague “virtual” (no hay acople de vehículo aquí)
});
addEventListener('contextmenu', e=>e.preventDefault());

// Controles UI agente
const $btnToggle = () => document.getElementById('btnToggle');
const $panel = () => document.getElementById('agentPanel');
const $advice = () => document.getElementById('agentAdvice');
const $reason = () => document.getElementById('agentReason');
// botones eliminados

addEventListener('DOMContentLoaded', ()=>{
  $btnToggle().addEventListener('click', toggleAgent);
  state.agent.enabled = true; // ON por defecto
  $btnToggle().setAttribute('aria-pressed','true');
});

/* ============================
   LÓGICA DE CAMBIOS
   ============================ */
function doUpshift(){
  if(state.gearIndex<=0){ say("Primero engrana 1ª (Shift+Space).", "warn"); return; }
  if(state.gearIndex >= cfg.gears.length-1){ say("Ya estás en la marcha más alta.", "warn"); return; }

  // Validar ventana óptima
  if(state.rpm < cfg.optimalMin){
    say("Necesitas más potencia (sube RPM antes de cambiar).", "warn");
    return;
  }
  if(state.rpm > 4000){
    say("¡Sobre-revolución! Baja la aceleración.", "warn");
    // permitimos el cambio, pero lo marcamos como no óptimo
  }

  const oldGear = cfg.gears[state.gearIndex];
  state.gearIndex += 1;
  const newGear = cfg.gears[state.gearIndex];

  // Ajuste instantáneo de RPM según relaciones
  const ratio = (oldGear.ratio || 1) / (newGear.ratio || 1);
  state.rpm = clamp(state.rpm * ratio, cfg.idleMin, cfg.redline);
  say(`Subiste a ${newGear.name}ª.`, (state.rpm>=cfg.optimalMin && state.rpm<=cfg.optimalMax)?'ok':'info');
}

function doDownshift(){
  if(state.gearIndex<=1){ // si estás en 1ª o N
    if(state.gearIndex===1){ state.gearIndex=0; say("Pasaste a Neutro (N).", "info"); }
    else say("Ya estás en Neutro.", "warn");
    return;
  }
  const oldGear = cfg.gears[state.gearIndex];
  state.gearIndex -= 1;
  const newGear = cfg.gears[state.gearIndex];

  // Ajuste de RPM hacia arriba por reducción
  const ratio = (oldGear.ratio || 1) / (newGear.ratio || 1);
  state.rpm = clamp(state.rpm / ratio, cfg.idleMin, cfg.hardMax);
  if(state.rpm > cfg.redline) say("Cuidado: reducción agresiva (RPM altas).", "warn");
  say(`Bajaste a ${newGear.name}ª.`, "info");
}

/* ============================
   BUCLE PRINCIPAL
   ============================ */
const cvs = document.getElementById('game');
const ctx  = cvs.getContext('2d');

/* ============================
   AUDIO DEL MOTOR (WebAudio)
   ============================ */
function ensureAudio(){
  if(state.audio.started) return;
  try{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const ac = new AudioCtx();
    const osc1 = ac.createOscillator(); // tono fundamental (pulso motor)
    const osc2 = ac.createOscillator(); // armónico
    const filter = ac.createBiquadFilter();
    const gain = ac.createGain();

    osc1.type = 'sawtooth';
    osc2.type = 'square';
    filter.type = 'lowpass';
    filter.frequency.value = 1200;
    gain.gain.value = 0.0; // silencio inicial

    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(ac.destination);

    const t = ac.currentTime + 0.01;
    osc1.start(t);
    osc2.start(t);

    state.audio = { ctx: ac, started: true, gain, osc1, osc2, filter };
  }catch(err){
    // si falla, no bloqueamos el simulador
    state.audio.started = false;
  }
}

function updateAudio(){
  if(!state.audio.started) return;
  const { ctx:ac, gain, osc1, osc2, filter } = state.audio;

  // Frecuencia base proporcional a RPM (pulsos por revolución aproximados)
  const baseHz = Math.max(28, (state.rpm/60) * 2);
  const tNow = ac.currentTime;
  if(osc1 && osc2){
    osc1.frequency.setTargetAtTime(baseHz, tNow, 0.03);
    osc2.frequency.setTargetAtTime(baseHz*2, tNow, 0.03);
  }

  // Intensidad y brillo según acelerador y marcha engranada
  const throttle = state.inputs.w && state.gearIndex>0 ? 1 : 0;
  const idleLevel = 0.02;
  const driveLevel = 0.12;
  const targetGain = throttle ? driveLevel : idleLevel;
  if(gain){
    gain.gain.setTargetAtTime(targetGain, tNow, 0.08);
  }
  if(filter){
    const cut = throttle ? 2000 : 1200;
    filter.frequency.setTargetAtTime(cut, tNow, 0.08);
    filter.Q.setTargetAtTime(throttle ? 0.8 : 0.5, tNow, 0.08);
  }
}

function step(){
  const t = performance.now();
  const dt = Math.min(0.05, (t - state.lastTime) / 1000); // dt en segundos (clamp 50 ms)
  state.lastTime = t;

  // factor de pausa progresiva (1 = normal, 0 = detenido)
  const targetSlow = state.agent.active ? 1 : 0;
  state.agent.slowing += (targetSlow - state.agent.slowing) * 0.08;
  const simSpeed = Math.max(0, 1 - state.agent.slowing);
  const dtEff = dt * simSpeed;

  // 1) Física sencilla de RPM
  const targetIdle = lerp(cfg.idleMin, cfg.idleMax, 0.35);
  let rpm = state.rpm;

  if(state.gearIndex>0 && state.inputs.w){
    rpm += cfg.accelPerSec * dtEff * 100;  // amplifica el efecto para hacerlo visible
  } else {
    // cae hacia ralentí
    const k = state.inputs.space ? (cfg.decayToIdleK + cfg.brakeK) : cfg.decayToIdleK;
    rpm += (targetIdle - rpm) * k * dtEff;
  }

  // límites
  rpm = clamp(rpm, cfg.idleMin*0.8, cfg.hardMax);
  state.rpm = rpm;

  // 2) Señal “momento óptimo” (desactivada durante agente)
  const inOptimal = (rpm >= cfg.optimalMin && rpm <= cfg.optimalMax && state.gearIndex>0 && state.gearIndex<cfg.gears.length-1);
  if(!state.agent.active && inOptimal && !state.justHitOptimal){
    say("¡Momento óptimo! Mantén embrague (Shift) y clic izquierdo para subir marcha.", "ok", 2400);
    state.justHitOptimal = true;
  }
  if(!inOptimal) state.justHitOptimal = false;

  // 2b) Métricas para detección de coaching
  updateCoachingMetrics(dtEff);
  maybeTriggerAgent();

  // 3) Render
  render();

  // 4) Audio
  updateAudio();

  requestAnimationFrame(step);
}

requestAnimationFrame(step);

/* ============================
   RENDER
   ============================ */
function render(){
  const w = cvs.width, h = cvs.height;

  // FONDO base
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#0a0e12";
  ctx.fillRect(0,0,w,h);

  // Interior del coche (parabrisas, pilares y tablero)
  drawCabin(ctx);

  // === Metáfora 1: “Más Luz, Más Velocidad”
  // brillo proporcional a RPM; elevamos luminancia con un overlay blanco translúcido
  const brightT = map(state.rpm, cfg.idleMin, cfg.redline, 0.05, 0.38);
  ctx.save();
    ctx.globalAlpha = brightT;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,w,h);
  ctx.restore();

  // === Barra de progreso vertical (cohete)
  drawRocketBar(ctx);

  // === Volante y Tablero (solo visual)
  drawSteeringWheel(ctx);
  drawInstrumentCluster(ctx);

  // === Tablero/HUD (donde puedes integrar los artefactos visuales del boceto)
  drawDashboard(ctx);

  // === Pedales (Embrague-Shift, Freno-Space, Acelerador-W)
  drawPedals(ctx);

  // === Mensajes del Agente
  drawAgentMessages(ctx);

  // === Comentarios para integrar UI del boceto ===
  // - Sustituye drawSteeringWheel() por imágenes SVG/PNG del volante/tablero.
  // - Reemplaza drawGearStickHint() por tu arte de palanca y animaciones.
  // - En drawRocketBar() puedes usar sprites: cohete, planeta/galaxia y barra.
}

/* ----- HUD principal: RPM, marcha y tips ----- */
function drawDashboard(ctx){
  const pad = 20;

  // Cartela superior derecha con RPM
  const rpmText = `Revoluciones: ${(state.rpm/1000).toFixed(1)} x 1000 rpm`;
  ctx.save();
    ctx.font = "20px system-ui, Segoe UI, Roboto, Arial";
    ctx.textAlign = "right"; ctx.textBaseline = "top";
    const tw = ctx.measureText(rpmText).width;
    const rpmBx = cvs.width - pad - tw - 30, rpmBy = pad, rpmBw = tw + 30, rpmBh = 38;
    ctx.fillStyle = "rgba(24,44,52,0.85)";
    roundRect(ctx, rpmBx, rpmBy, rpmBw, rpmBh, 14); ctx.fill();
    ctx.fillStyle = "#e5f6ff";
    ctx.fillText(rpmText, cvs.width - pad - 16, rpmBy+9);
  ctx.restore();

  // Caja inferior con estado de marcha y controles
  const gear = cfg.gears[state.gearIndex].name;
  const status = `Marcha: ${gear}    ${state.inputs.shift?'[Embrague: ON]':'[Embrague: OFF]'}    ${state.inputs.w?'[Acelerando]':''} ${state.inputs.space?'[Frenando]':''}`;
  ctx.save();
    ctx.font = "18px system-ui, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillStyle = "rgba(24,44,52,0.85)";
    const statusBw = 720, statusBh = 44, statusBx = (cvs.width-statusBw)/2, statusBy = cvs.height-20-statusBh;
    roundRect(ctx, statusBx, statusBy, statusBw, statusBh, 12); ctx.fill();
    ctx.fillStyle = "#d8ecff";
    ctx.fillText(status, cvs.width/2, statusBy+statusBh-12);
  ctx.restore();

  // Hint de palanca (clic izq/der + Shift)
  drawGearStickHint(ctx);
}

/* ----- Interior del coche (parabrisas/pilares/tablero superior) ----- */
function drawCabin(ctx){
  const w = cvs.width, h = cvs.height;
  ctx.save();
    // Parabrisas degradado
    const sky = ctx.createLinearGradient(0,0,0,h*0.5);
    sky.addColorStop(0, "#0e1520");
    sky.addColorStop(1, "#0a0e12");
    ctx.fillStyle = sky;
    ctx.beginPath();
    ctx.moveTo(80, 40);
    ctx.quadraticCurveTo(w/2, 10, w-80, 40);
    ctx.lineTo(w-60, h*0.42);
    ctx.quadraticCurveTo(w/2, h*0.48, 60, h*0.42);
    ctx.closePath();
    ctx.fill();

    // Pilares A izquierdo/derecho
    ctx.fillStyle = "#1a2129";
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(120,0); ctx.lineTo(80,220); ctx.lineTo(0,260); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(w,0); ctx.lineTo(w-120,0); ctx.lineTo(w-80,220); ctx.lineTo(w,260); ctx.closePath(); ctx.fill();

}

/* ----- Pedales con feedback visual ----- */
function drawPedals(ctx){
  const areaW = 520;
  const areaH = 160;
  const baseY = cvs.height - 80 - areaH;
  const baseX = (cvs.width - areaW)/2;

  const pedals = [
    { key:'shift', label:'Shift', x: baseX,          w: 150 }, // Embrague
    { key:'space', label:'Space', x: baseX + 185,    w: 150 }, // Freno
    { key:'w',     label:'W',     x: baseX + 370,    w: 150 }, // Acelerador
  ];

  pedals.forEach((p, i)=>{
    const pressed = !!state.inputs[p.key];
    const y = baseY + (pressed ? 10 : 0);
    const h = areaH - (pressed ? 16 : 0);
    ctx.save();
      // Sombra
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(ctx, p.x+6, baseY+areaH-10, p.w-12, 10, 6); ctx.fill();
      ctx.globalAlpha = 1;

      // Cuerpo del pedal
      const grad = ctx.createLinearGradient(p.x, y, p.x, y+h);
      grad.addColorStop(0, pressed?"#9fc7ff":"#d3e4f7");
      grad.addColorStop(1, pressed?"#7ca7e6":"#bcd3ea");
      ctx.fillStyle = grad;
      roundRect(ctx, p.x, y, p.w, h, 14); ctx.fill();

      // Borde
      ctx.strokeStyle = pressed?"#5e85b8":"#7f9fbf";
      ctx.lineWidth = 2;
      roundRect(ctx, p.x, y, p.w, h, 14); ctx.stroke();

      // Etiqueta
      ctx.fillStyle = "#10202a";
      ctx.font = "22px system-ui";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(p.label, p.x + p.w/2, y + h/2);
    ctx.restore();
  });

  ctx.save();
    ctx.fillStyle = "rgba(220,235,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText("Pedal Embrague (Shift)", cvs.width/2.8, baseY - 0.1);
  ctx.restore();

  ctx.save();
    ctx.fillStyle = "rgba(220,235,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText("Pedal Freno (Space)", cvs.width/2, baseY - 0.1);
  ctx.restore();

  ctx.save();
    ctx.fillStyle = "rgba(220,235,255,0.75)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center"; ctx.textBaseline = "bottom";
    ctx.fillText("Pedal Acelerador (W)", cvs.width/1.55, baseY - 0.1);
  ctx.restore();
  
}

function drawGearStickHint(ctx){
  ctx.save();
    const x = cvs.width - 220, y = cvs.height - 220;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(ctx, x, y, 200, 140, 14); ctx.fill();

    ctx.font = "14px system-ui, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "#c9d9ff";
    ctx.textAlign = "left"; ctx.textBaseline = "top";
    ctx.fillText("Cambios (mantén Shift):", x+12, y+10);
    ctx.fillText("• Clic Izq: Subir marcha", x+12, y+36);
    ctx.fillText("• Clic Der: Bajar marcha", x+12, y+58);
    ctx.fillText("N → 1ª: Shift + Space", x+12, y+92);
  ctx.restore();
}

/* ----- Metáfora 2: Cohete/Galaxia (progreso RPM) ----- */
function drawRocketBar(ctx){
  const bar = { x: 40, y: 80, w: 46, h: cvs.height - 160, r: 16 };
  // Barra contenedor
  ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    roundRect(ctx, bar.x, bar.y, bar.w, bar.h, bar.r); ctx.fill();

    // Planeta/galaxia: marca del umbral óptimo (entre 2500-3500 rpm).
    const tOpt = map(state.rpm, cfg.idleMin, cfg.redline, 0, 1); // no usado para la posición del planeta
    const optMid = (cfg.optimalMin + cfg.optimalMax)/2;
    const optY = map(optMid, cfg.idleMin, cfg.redline, bar.y+bar.h-24, bar.y+24);

    // Línea/“planeta” objetivo
    ctx.beginPath();
    ctx.arc(bar.x + bar.w/2, optY, 14, 0, Math.PI*2);
    ctx.fillStyle = "rgba(80,180,255,0.25)";
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#4ac0ff";
    ctx.stroke();

    // Zona óptima (banda)
    const optY1 = map(cfg.optimalMax, cfg.idleMin, cfg.redline, bar.y+bar.h, bar.y);
    const optY2 = map(cfg.optimalMin, cfg.idleMin, cfg.redline, bar.y+bar.h, bar.y);
    ctx.fillStyle = "rgba(74,192,255,0.12)";
    ctx.fillRect(bar.x+6, optY1, bar.w-12, Math.max(6, optY2-optY1));

    // Progreso del cohete según RPM
    const t = map(state.rpm, cfg.idleMin, cfg.redline, 0, 1);
    const rocketY = map(state.rpm, cfg.idleMin, cfg.redline, bar.y+bar.h-20, bar.y+20);

    // “Combustible” (relleno)
    ctx.fillStyle = "linear-gradient(#fff,#fff)"; // placeholder
    ctx.fillStyle = "rgba(74,192,255,0.35)";
    const fillTop = rocketY;
    roundRect(ctx, bar.x+10, fillTop, bar.w-20, bar.y+bar.h - fillTop, 8); ctx.fill();

    // Cohete (placeholder vectorial; aquí puedes colocar tu sprite PNG/SVG)
    drawRocketIcon(ctx, bar.x + bar.w/2, rocketY);

    // Marcas de escala
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 1;
    const steps = 6;
    for(let i=0;i<=steps;i++){
      const yy = map(i/steps, 0,1, bar.y+bar.h, bar.y);
      ctx.beginPath(); ctx.moveTo(bar.x+bar.w+6, yy); ctx.lineTo(bar.x+bar.w+18, yy); ctx.stroke();
      const rpmMark = Math.round(lerp(cfg.idleMin, cfg.redline, i/steps)/100)*100;
      ctx.fillStyle = "rgba(220,235,255,0.6)";
      ctx.font = "12px system-ui"; ctx.textAlign = "left"; ctx.textBaseline = "middle";
      ctx.fillText(`${(rpmMark/1000).toFixed(1)}k`, bar.x+bar.w+22, yy);
    }
  ctx.restore();
}

/* ----- Volante (visual, centrado) ----- */
function drawSteeringWheel(ctx){
  const size = 280;
  const pad = 28;
  const x = cvs.width/2;
  const y = cvs.height/2.1;

  ctx.save();
    // contenedor suave
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(ctx, x - size/2 - 8, y - size/2 - 8, size + 16, size + 16, 14); ctx.fill();

    const outerR = size/2;        // aro exterior
    const innerR = outerR * 0.78; // aro interior

    // aro exterior (tono marfil)
    ctx.fillStyle = "#e9e2d4";
    ctx.beginPath();
    ctx.arc(x,y, outerR, 0, Math.PI*2);
    ctx.arc(x,y, outerR-14, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(40,40,40,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x,y, outerR-7, 0, Math.PI*2); ctx.stroke();

    // aro interior (metal pulido)
    const metal = ctx.createLinearGradient(x-innerR, y-innerR, x+innerR, y+innerR);
    metal.addColorStop(0, "#9fb3bf");
    metal.addColorStop(0.5, "#c7d6df");
    metal.addColorStop(1, "#90a3ae");
    ctx.fillStyle = metal;
    ctx.beginPath();
    ctx.arc(x,y, innerR, 0, Math.PI*2);
    ctx.arc(x,y, innerR-10, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.fill();

    // centro con emblema de 3 puntas
    const hubR = innerR*0.46;
    ctx.fillStyle = "#1f2a33";
    ctx.beginPath(); ctx.arc(x,y, hubR+6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#dbe9f3";
    ctx.beginPath(); ctx.arc(x,y, hubR, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#97aebe";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x,y, hubR, 0, Math.PI*2); ctx.stroke();

    // estrella de tres puntas simplificada
    const starR = hubR*0.86;
    ctx.strokeStyle = "#32505f";
    ctx.lineWidth = 3;
    for(let i=0;i<3;i++){
      const a = -Math.PI/2 + i*(2*Math.PI/3);
      const px = x + Math.cos(a)* starR;
      const py = y + Math.sin(a)* starR;
      ctx.beginPath();
      ctx.moveTo(x,y); ctx.lineTo(px,py); ctx.stroke();
    }
    ctx.strokeStyle = "#7fa4b6";
    ctx.lineWidth = 1.6;
    ctx.beginPath(); ctx.arc(x,y, starR, 0, Math.PI*2); ctx.stroke();
  ctx.restore();
}

/* ----- Tablero / Instrument Cluster (visual, zona superior central) ----- */
function drawInstrumentCluster(ctx){
  const clusterW = 320;
  const clusterH = 160;
  const x = (cvs.width - clusterW)/2;
  const y = 72;

  ctx.save();
    // contenedor
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    roundRect(ctx, x, y, clusterW, clusterH, 16); ctx.fill();

    // tacómetro circular a la izquierda
    const cx = x + 110;
    const cy = y + clusterH/2 + 10;
    const rOuter = 62;
    const rInner = 50;

    // fondo
    ctx.fillStyle = "#152027";
    ctx.beginPath(); ctx.arc(cx,cy,rOuter,0,Math.PI*2); ctx.fill();

    // arco de zona óptima
    const aStart = Math.PI*1.2; // -144°
    const aEnd   = Math.PI*1.95; // ~+171°
    const optT1 = (cfg.optimalMin - cfg.idleMin) / (cfg.redline - cfg.idleMin);
    const optT2 = (cfg.optimalMax - cfg.idleMin) / (cfg.redline - cfg.idleMin);
    const optA1 = aStart + (aEnd-aStart)*optT1;
    const optA2 = aStart + (aEnd-aStart)*optT2;
    ctx.strokeStyle = "rgba(74,192,255,0.45)";
    ctx.lineWidth = 10;
    ctx.beginPath(); ctx.arc(cx,cy,rInner, optA1, optA2); ctx.stroke();

    // marcas
    ctx.strokeStyle = "rgba(220,235,255,0.5)";
    ctx.lineWidth = 2;
    const marks = 6;
    for(let i=0;i<=marks;i++){
      const t = i/marks;
      const a = aStart + (aEnd-aStart)*t;
      const x1 = cx + Math.cos(a)* (rInner-8);
      const y1 = cy + Math.sin(a)* (rInner-8);
      const x2 = cx + Math.cos(a)* (rInner+8);
      const y2 = cy + Math.sin(a)* (rInner+8);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.fillStyle = "rgba(220,235,255,0.7)";
      ctx.font = "12px system-ui"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
      const lx = cx + Math.cos(a)* (rInner+20);
      const ly = cy + Math.sin(a)* (rInner+20);
      const rpmMark = lerp(cfg.idleMin, cfg.redline, t)/1000;
      ctx.fillText(`${rpmMark.toFixed(1)}k`, lx, ly);
    }

    // aguja según RPM
    const tRpm = (state.rpm - cfg.idleMin) / (cfg.redline - cfg.idleMin);
    const aNeedle = aStart + (aEnd-aStart) * clamp(tRpm,0,1);
    const nx = cx + Math.cos(aNeedle)* (rInner+2);
    const ny = cy + Math.sin(aNeedle)* (rInner+2);
    ctx.strokeStyle = "#ffb47a";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
    ctx.fillStyle = "#e9f6ff";
    ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill();

    // cuadro informativo a la derecha (marcha actual)
    const gear = cfg.gears[state.gearIndex].name;
    const bx = x + 200, by = y + 30, bw = 96, bh = 96;
    ctx.fillStyle = "rgba(24,44,52,0.85)";
    roundRect(ctx, bx, by, bw, bh, 12); ctx.fill();
    ctx.fillStyle = "#cfe6ff";
    ctx.font = "14px system-ui"; ctx.textAlign = "center"; ctx.textBaseline = "top";
    ctx.fillText("Marcha", bx + bw/2, by + 8);
    ctx.font = "46px system-ui"; ctx.textBaseline = "middle";
    ctx.fillText(gear, bx + bw/2, by + bh/2 + 6);
  ctx.restore();
}

function drawRocketIcon(ctx, cx, cy){
  ctx.save();
    ctx.translate(cx, cy);
    // cuerpo
    ctx.fillStyle = "#bfe6ff";
    ctx.beginPath();
    ctx.moveTo(0,-12);
    ctx.quadraticCurveTo(10,-2, 8,10);
    ctx.lineTo(-8,10);
    ctx.quadraticCurveTo(-10,-2, 0,-12);
    ctx.fill();

    // ventanilla
    ctx.beginPath();
    ctx.arc(0,-4,4,0,Math.PI*2);
    ctx.fillStyle = "#203040";
    ctx.fill();

    // llama
    ctx.beginPath();
    ctx.moveTo(0,14);
    ctx.lineTo(5,22);
    ctx.lineTo(-5,22);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,180,120,0.9)";
    ctx.fill();
  ctx.restore();
}

/* ============================
   DETECCIÓN Y SESIÓN DEL AGENTE
   ============================ */
function updateCoachingMetrics(dt){
  if(state.gearIndex===0) state.agent.metrics.timeInNeutral += dt; else state.agent.metrics.timeInNeutral = 0;
  if(state.rpm > cfg.redline*0.93) state.agent.metrics.timeAboveRed += dt; else state.agent.metrics.timeAboveRed = 0;
  if(!state.inputs.shift && state.inputs.w && state.gearIndex>0) state.agent.metrics.timeNoClutchAttempt += dt; else state.agent.metrics.timeNoClutchAttempt = 0;
  pushHistoryTick();
}

function detectCoachingReason(){
  if(state.agent.metrics.timeInNeutral > 8) return 'Mucho tiempo en Neutro. Practicar arranque: embrague + freno, luego acelera suave.';
  if(state.agent.metrics.timeAboveRed > 2) return 'RPM muy altas cerca de la zona roja. Sube de marcha dentro del rango óptimo (2.5k-3.5k).';
  if(state.agent.metrics.timeNoClutchAttempt > 5) return 'Aceleras sin usar embrague. Coordina embrague (Shift) con aceleración para transiciones suaves.';
  return '';
}

function maybeTriggerAgent(){
  if(!state.agent.enabled || state.agent.active) return;
  const reason = detectCoachingReason();
  if(!reason) return;
  const nowMs = now();
  if(nowMs - state.agent.lastTrigger < state.agent.cooldownMs) return; // cooldown
  startAgentSession(reason);
}

async function startAgentSession(reason){
  state.agent.active = true;
  state.agent.reason = reason || 'Asesoramiento del sistema';
  state.agent.lastTrigger = now();
  $reason().textContent = 'Motivo: ' + state.agent.reason;
  $advice().textContent = 'Analizando tu conducción y consultando al agente...';
  $panel().style.display = 'flex';

  const snapshot = buildAgentSnapshot();
  const key = (state.agent.apiKey || '').trim();
  if(!key){
    $advice().textContent = localFallbackAdvice(snapshot);
    return;
  }
  try{
    await delay(700 + Math.random()*500); // pequeño retardo intencional
    const text = await fetchGeminiAdvice(key, snapshot);
    $advice().textContent = text || localFallbackAdvice(snapshot);
  }catch(err){
    $advice().textContent = localFallbackAdvice(snapshot) + '\n\n[Nota: no se pudo contactar a Gemini]';
  }
}

function endAgentSession(){
  state.agent.active = false;
  $panel().style.display = 'none';
  $btnResume().style.display = 'none';
  $coachStatus().textContent = '';
  state.agent.reason = '';
}

function buildAgentSnapshot(){
  return {
    rpm: Math.round(state.rpm),
    gear: cfg.gears[state.gearIndex].name,
    inputs: { accelerating: !!state.inputs.w, braking: !!state.inputs.space, clutch: !!state.inputs.shift },
    optimalRange: { min: cfg.optimalMin, max: cfg.optimalMax },
    redline: cfg.redline,
    reason: state.agent.reason,
    history: state.agent.history.slice(-20),
    action: inferDriverAction(),
    intendedChange: inferIntendedChange(),
    pedalsPct: estimatePedalsPct()
  };
}

function localFallbackAdvice(s){
  return (
    `Consejo técnico:\n- Marcha: ${s.gear}. RPM: ${s.rpm}. Rango óptimo: ${s.optimalRange.min}-${s.optimalRange.max}.\n`+
    `Recomendación práctica:\n- ${state.agent.reason}\n- Practica coordinando embrague (Shift) y acelerador (W).\n`+
    `Motivación:\n- Paso a paso. Cada intento mejora tu sensibilidad y control. 💪`
  );
}

async function fetchGeminiAdvice(apiKey, snapshot){
  const prompt = buildGeminiPrompt(snapshot);
  const body = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      temperature: 0.6,
      maxOutputTokens: 350,
    }
  };
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(apiKey)}`;
  const res = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body) });
  if(!res.ok) throw new Error('Gemini API error');
  const json = await res.json();
  const text = json?.candidates?.[0]?.content?.parts?.[0]?.text || '';
  return sanitizeGeminiText(text);
}

function buildGeminiPrompt(s){
  return [
    'Actúa como un copiloto de conducción experimentado, paciente y amigable.',
    '',
    'Objetivo: Proporcionar consejos o correcciones inmediatas, junto con una justificación teórica simple, sobre la maniobra de conducción manual que se está realizando en tiempo real.',
    '',
    'Definición de Agente de Conducción Manual: Soy un sistema (agente) que monitoriza las interacciones del conductor humano con el vehículo. Mi propósito es analizar estas acciones (cambio de marcha, uso de pedales, revoluciones) para evaluar la técnica y ofrecer feedback constructivo que mejore la eficiencia, seguridad y suavidad de la conducción.',
    '',
    'Datos Actuales de la Maniobra:',
    `- Acción del conductor: ${s.action}`,
    `- Marcha Actual: ${s.gear}.`,
    `- Cambio Solicitado/Previsto: ${s.intendedChange}.`,
    `- Revoluciones (RPM): ${s.rpm} RPM.`,
    `- Pedales (estado/uso): Freno: ${s.pedalsPct.brake}% pisado, Clutch: ${s.pedalsPct.clutch}% pisado, Acelerador: ${s.pedalsPct.throttle}% pisado.`,
    '',
    'Tarea: Analiza los datos de la maniobra e inmediatamente proporciona:',
    '1. Consejo/Corrección: Una frase clara y directa sobre qué hacer (ej: "Sube la marcha ahora" o "Disminuye la presión del embrague").',
    '2. Justificación Teórica Amigable: Una explicación concisa y fácil de entender del por qué de la corrección, enfocada en la seguridad, la eficiencia del combustible o el cuidado mecánico del vehículo (ej: "Esto evitará que el motor se revolucione demasiado, lo que es mejor para el consumo y el desgaste").',
    '',
    'Formato de Salida:',
    '¡ALERTA DE CONDUCCIÓN!\nConsejo: <tu consejo/corrección>\nPor qué: <justificación teórica>'
  ].join('\n');
}

function sanitizeGeminiText(t){
  return String(t||'')
    .replace(/```[\s\S]*?```/g, '')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

function toggleAgent(){
  state.agent.enabled = !state.agent.enabled;
  const on = state.agent.enabled;
  $btnToggle().textContent = `Apoyo de agente: ${on?'ON':'OFF'}`;
  $btnToggle().setAttribute('aria-pressed', on?'true':'false');
}

function pushHistoryTick(){
  const entry = {
    t: Math.round(performance.now()),
    rpm: Math.round(state.rpm),
    gear: cfg.gears[state.gearIndex].name,
    inputs: { w: !!state.inputs.w, space: !!state.inputs.space, shift: !!state.inputs.shift },
    type: classifyActionType(),
    detail: actionDetailString()
  };
  state.agent.history.push(entry);
  if(state.agent.history.length>120) state.agent.history.shift();
}

function classifyActionType(){
  if(state.gearIndex===0 && state.inputs.w) return 'acel_neutro';
  if(state.inputs.w && !state.inputs.shift && state.gearIndex>0) return 'acel_sin_embrague';
  if(state.rpm>cfg.redline*0.93) return 'rpm_altas';
  if(state.inputs.space) return 'frenando';
  if(state.inputs.shift) return 'embrague';
  return 'normal';
}

function actionDetailString(){
  return `rpm=${Math.round(state.rpm)}, gear=${cfg.gears[state.gearIndex].name}, W=${!!state.inputs.w}, Space=${!!state.inputs.space}, Shift=${!!state.inputs.shift}`;
}

function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

function inferDriverAction(){
  const last = state.agent.history[state.agent.history.length-1];
  if(!last) return 'Observando la marcha y las RPM.';
  switch(last.type){
    case 'acel_neutro': return 'Acelerando en Neutro.';
    case 'acel_sin_embrague': return 'Acelerando sin usar embrague en marcha engranada.';
    case 'rpm_altas': return 'Manteniendo RPM altas cerca de zona roja.';
    case 'frenando': return 'Frenando.';
    case 'embrague': return 'Usando el embrague.';
    default: return 'Conducción normal sin cambios recientes.';
  }
}

function inferIntendedChange(){
  // Heurística simple: si RPM altas y en marcha < 5, sugiere subir; si en Neutro y freno+embrague, sugiere iniciar en 1ª
  const gearIdx = state.gearIndex;
  if(gearIdx===0){
    if(state.inputs.shift && state.inputs.space) return 'Iniciar movimiento: subir a 1ª';
    return 'Mantener en Neutro';
  }
  if(state.rpm > cfg.optimalMax && gearIdx < cfg.gears.length-1) return `Subir a ${cfg.gears[gearIdx+1].name}ª`;
  if(state.rpm < cfg.optimalMin && gearIdx > 1) return `Bajar a ${cfg.gears[gearIdx-1].name}ª`;
  return 'Mantener';
}

function estimatePedalsPct(){
  // Como no hay presión analógica real, mapear booleanos a 0/100 y freno suave si cae a ralentí con Space
  const throttle = state.inputs.w ? 100 : 0;
  const brake = state.inputs.space ? 25 : 0; // aproximación visual
  const clutch = state.inputs.shift ? 100 : 0;
  return { throttle, brake, clutch };
}


</script>
</body>
</html>
